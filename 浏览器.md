# 浏览器

## cookie 与 本地存储 相关

### cookie 的使用

```js
// 设置
document.cookie = 'age=16' // 每次只能设置一对cookie

// 获取
document.cookie // 获取全部cookie值，获取特定用循环

// 删除
document.cookie = 'name=xiaoming; max-age=-1000' // 设置一个当前之前的时间即可

// 设置过期时间
var name = 'one_name'
var value = '123'
var exp = new Date()
exp.setTime(exp.getTime() + 60 * 2000) // 过期时间 2分钟
document.cookie = name + "=" + escape(value) + ";expires=" + exp.toGMTString()
console.log(name + "=" + escape(value) + ";expires=" + exp.toGMTString())

// 如果不在浏览器中设置过期时间，cookie 被保存在内存中，生命周期随浏览器的关闭而结束，
// 这种 cookie 简称会话 cookie。
// 如果在浏览器中设置了 cookie 的过期时间，cookie 被保存在硬盘中，
// 关闭浏览器后，cookie 数据仍然存在，直到过期时间结束才消失。
```

### cookie, localStorage 和 sessionStorage 的区别

#### 用途

- cookie：是服务器发给浏览器保存的（字符串）数据，一般用来记录用户信息方便服务端确认用户身份
- localStorage、sessionStorage：本地存储，可以保存一些不太重要的数据，例如当前用户坐标，购物车信息等

#### 存储大小

- cookie：4k
- localStorage, sessionStorage：5M

#### 有效期

- cookie：关闭浏览器失效（默认）
- localStorage：永久，除非js手动删和清除浏览器缓存
- sessionStorage：页面不关闭就不失效，包括重新加载或恢复页面也不失效。但在新标签或窗口打开一个页面，则会重新生成

### cookie 与 session 区别

都是用来确认用户身份的，区别在于 cookie 保存在客户端，session 保存在服务端。

另外，session 是基于 cookie 的。服务器端在生成 session 后，会让客户端的 cookie 代为保存 sessionID 。

![cookie](https://cdn.nlark.com/yuque/0/2019/png/260235/1550245038963-b61378bb-65db-411e-9069-cf7d2b7a2908.png)

![session](https://cdn.nlark.com/yuque/0/2019/png/260235/1550245194054-9e6b0a42-c09e-4a8b-8e7e-93ba715e6e5a.png)

阅读：

- [一文带你看懂cookie，面试前端不用愁](https://segmentfault.com/a/1190000017332168)
- [聊一聊cookie](https://juejin.im/post/5b18d322e51d4506cf10af7c)
- [Cookie禁用了，Session还能用吗？](https://segmentfault.com/q/1010000007715137)
- [session,cookie,sessionStorage,localStorage的区别及应用场景](https://www.jianshu.com/p/cc951b6a75e3)

### HTML5的离线储存使用，解释工作原理？❌

> 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5的离线存储是基于一个新建的 .appcache 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。

如何使用：

1. 页面头部像下面一样加入一个manifest的属性
2. 在 cache.manifest 文件的编写离线存储的资源
3. 在离线状态时，操作 window.applicationCache 进行需求实现。

详细的使用请参考：

- [HTML5 离线缓存-manifest简介](http://yanhaijing.com/html/2014/12/28/html5-manifest/)
- [有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617)

### 浏览器对 HTML5 离线储存资源的管理和加载？

在线的情况下:

浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问 app ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。

离线的情况下:

浏览器就直接使用离线存储的资源。

### 用户点外卖的份数怎么和后台通信？万一用户中断了再进了怎么获取？为什么不用 cookie？

- 将购物车信息存在 localStorage
- 从 localStorage 中获取
- 用户禁用 cookie 时无法使用

## 兼容性

### 经常遇到的浏览器的兼容性有哪些？

- IE 浏览器不支持 Promise
   - babel-polyfill → webpack.config.js 的 entry 中设置 ['babel-polyfill', './src/main.js']
- 各浏览器之间默认样式的差异
   - normalize.css
      - 与 reset 区别 → normalize.css 消除各浏览器之间默认样式的差异、保留有用的默认样式；而 reset 会清除所有的默认样式，过于暴力，例如会让 h 标题标签不再默认加粗，ul li 前面默认的小圆点也没了）
- html5 某些新增标签不被识别
   - html5shiv.js - 解决 ie9 以下对 html5 某些新增标签不识别的问题（e.g. video标签不识别不显示）
      - 用法：`[if lt IE 9]><script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script><![endif]`
   - 通过 document.createElement 方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签，浏览器支持新标签后，还需要添加标签默认的样式。
- CSS3 媒体查询失效
   - respond.js - 能解决 ie9 以下不支持媒体查询问题
- 自动添加浏览器前缀
   - posscss-loader+autoprefixer
- ie6 不支持 min-height/width
   - 添加额外的 `_min-height` ie6 识别
- 常见hack（针对特定ie版本的样式控制）
   - _color - ie6 识别
   - *color - ie6/7 识别
   - color: red\9; ie8及以下识别
- ie条件注释写法：(lt 小于 | gt 大于 | lte 小于等于 | gte 大于等于 | ! 不等于)

### 移动端兼容性呢？

- 移动端点透问题
   - [解决方案](https://www.cnblogs.com/zhuzhenwei918/p/7588553.html)
- ios滚动卡顿
   - 使用 better-scroll 插件
- ios 顶部输入框 fixed 布局失效（当键盘弹起时）❌
- 安卓 键盘遮挡输入框 ❌

#### position:fixed; 在 android 下无效怎么处理？【❌待验证】

原因：

fixed 的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的 viewport ，
原来的网页还好好的在那，fixed 的内容也没有变过位置。

解决：

```html
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no"/>
```

#### 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？❌

click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。

#### 在做移动端项目时遇到过什么问题？

参考阅读：[H5与APP混合开发遇到的问题总结](https://juejin.im/post/5aa8b00c51882555627cfa0e)

### Polyfill

#### 什么是 Polyfill

polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。

例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象，
所有这些都是 W3C 地理位置 API 定义的对象和函数。

因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发，
一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。

#### 做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？❌

比如： html5shiv、Geolocation、Placeholder

### 列举IE与其他浏览器不一样的特性？

#### 事件目标对象

触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性

#### 获取字符代码

如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性

#### 阻止某个事件的默认行为

IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法

#### 停止事件冒泡

IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()

## 通信

### 如何实现浏览器内多个标签页之间的通信? (阿里)

WebSocket、SharedWorker；

也可以调用 localStorage 、cookies 等本地存储方式；

localStorage 另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件， 我们通过监听事件，控制它的值来进行页面信息通信；

注意：Safari 在无痕模式下设置localStorage 值时会抛出  QuotaExceededError 的异常；

### webSocket 如何兼容低浏览器？(阿里)

Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR

## 页面渲染与缓存

### 浏览器渲染页面的过程

从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面 [五件事情](https://developers.google.com/speed/docs/insights/mobile) 上：

1. DNS 查询
2. TCP 连接
3. HTTP 请求即响应
4. 服务器响应
5. 客户端渲染

浏览器对内容的渲染，这一部分（渲染树构建、布局及绘制），又可以分为下面 [五个步骤](https://link.juejin.im/?target=http%3A%2F%2Flink.zhihu.com%2F%3Ftarget%3Dhttps%3A%2F%2Fdevelopers.google.com%2Fweb%2Ffundamentals%2Fperformance%2Fcritical-rendering-path%2Frender-tree-construction) ：

1. 处理 HTML 标记并构建 DOM 树。
2. 处理 CSS 标记并构建 CSSOM 树。
3. 将 DOM 与 CSSOM 合并成一个渲染树。
4. 根据渲染树来布局，以计算每个节点的几何信息。
5. 将各个节点绘制到屏幕上。

> 这五个步骤并不一定一次性顺序完成。如果 DOM 或 CSSOM 被修改，以上过程需要重复执行，这样才能计算出哪些像素需要在屏幕上进行重新渲染。实际页面中，CSS 与 JavaScript 往往会多次修改 DOM 和 CSSOM

参考来源：[浏览器的渲染：过程与原理](https://juejin.im/entry/59e1d31f51882578c3411c77)

### style 标签写在 body 后与 body 前（head）有什么区别？

style 标签放在 body 后，会导致当加载到此样式时，页面将停止之前的渲染。此样式表被解析后，将重新渲染页面，也就出现了短暂的花屏现象。

所以不要写在 body 后，要把样式放在 head 中。

### 缓存策略执行过程

![http缓存策略](https://cdn.nlark.com/yuque/0/2019/jpeg/260235/1549091602173-872e7ae7-1532-4933-a7e6-4f53f2e9ceb8.jpeg)

#### 一个 Response Header 示例

![res header](https://cdn.nlark.com/yuque/0/2019/jpeg/260235/1549091477928-50957a41-1e84-437f-8f6e-992f430730f4.jpeg)

### 强缓存与协商缓存的异同

- 相同点：最终都是走的本地缓存
- 不同点：强缓存不发请求，直接读本地缓存。协商缓存发请求到服务器

#### 基本原理

- 1）浏览器在加载资源时，根据请求头的 `expires` 和 `cache-control` 判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。
- 2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过 `last-modified` 和 `Etag` 验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源
- 3）如果前面两者都没有命中，直接从服务器加载资源

![强缓存vs协商缓存](https://cdn.nlark.com/yuque/0/2019/jpeg/260235/1550494473608-b1c458fe-f534-4674-ba30-32fc27deffd6.jpeg)

### expires 和 cache-control 的区别

都是用的本地系统时间，但

- expires 存的是个服务端绝对时间，修改客户端系统时间会有影响
- cache-control 是相对时间，即使客户端时间发生改变，相对时间也不会随之改变。例如设置 max-age = 10s，那么在 10s 以内，使用浏览器缓存的资源
- cache-control 的优先级高于 expires

## 其它

### 检测浏览器版本版本有哪些方式？

功能检测、userAgent特征检测

```js
比如：navigator.userAgent
//"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36
(KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36"
```

### 介绍一下你对浏览器内核的理解

主要分成两部分：

渲染引擎(Layout engineer 或Rendering Engine)和JS引擎。

- 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。
- JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

> 详细文章：[浏览器内核的解析和对比](http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html)

### 页面可见性(Page Visibility API)有哪些用途

- 通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等;
- 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放；

### 网页验证码干嘛的,是为了解决什么安全问题

区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水；
有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。

### 如果需要手动写动画，你认为最小时间间隔是多久，为什么？

多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms

### 第一次访问页面中时弹出引导，用户关闭引导，之后再次进入页面时不希望出现引导，如何实现？❌

localStorage

### 实现一个页面操作不会整页刷新的网站，并且能在浏览器的前进，后退时正确响应。给出你的技术实现方案？

- onhashchange
- window.history.pushState（添加新的历史记录）/replaceState(state,title, url)【改掉当前历史记录】
   - 配合 onpopstate 事件来监听历史记录的改变